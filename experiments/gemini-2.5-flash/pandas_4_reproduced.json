{
  "buggy_or_not": "Yes",
  "major_bug": "Variable Not Found",
  "root_cause": "Implementation error: The notebook failed to load the dataset into the `data` variable before attempting to use it, leading to subsequent variables also being undefined.",
  "analysis": [
    {
      "type": "text",
      "text": "Yes, I previously assessed the notebook as buggy.\n\nHere's a detailed bug and vulnerability analysis based on the notebook content and the provided runtime execution report:\n\n### Detailed Bug and Vulnerability Analysis\n\n**1. Correctness Analysis**\n\nThe primary issue identified in the notebook is a series of cascading errors stemming from incorrect data handling and inconsistencies in class definitions.\n\n*   **Major Bug: Variable Not Found (Root Cause: Implementation Error)**\n    *   **Issue:** The `data` DataFrame, which is central to the entire analysis, was not loaded from the `fer2013.csv` file at the appropriate point in the original notebook. The runtime report, however, shows that a cell was added at `cell_index: 4` to load the data: `data = pd.read_csv('data/fer2013.csv')`. This *fixes* the `NameError` for `data` itself.\n    *   **Impact:** In the original notebook, this would have caused `NameError` in almost every subsequent cell that tried to access `data` or variables derived from it (e.g., `emotion_counts`, `data_train`, `train_X`). The runtime report confirms that this specific `NameError` was addressed by the user adding the data loading cell.\n    *   **Correction/Improvement:** The user has already implemented the fix by adding `data = pd.read_csv('data/fer2013.csv')` at `cell_index: 4`. This is the correct approach.\n\n*   **Bug: `IndexError` in Image Visualization (Root Cause: Data Confusion / Implementation Error)**\n    *   **Issue:** The notebook's \"Objectives\" state a 7-class classification problem, but a subsequent code cell (`cell_index: 9`) explicitly removes all data points corresponding to `emotion == 1` (which is 'Disgust'). The `emotion_map` in `cell_index: 10` is then updated to reflect 6 classes, but the image display loop (`cell_index: 13`) still attempts to iterate through `range(1,8)`, trying to access `data[data['emotion'] == 1]`. Since emotion `1` has been removed, this results in an empty DataFrame, and calling `.iloc[0]` on it raises an `IndexError: single positional indexer is out-of-bounds`. The runtime report confirms this `IndexError` at `cell_index: 13`.\n    *   **Impact:** Prevents the visualization of example images and highlights a fundamental inconsistency between the stated objectives and the data preprocessing.\n    *   **Correction/Improvement:**\n        1.  **Consistency:** Decide whether to keep 'Disgust' (7 classes) or remove it (6 classes). Given the runtime report shows the removal cell executed, we will assume the intent is 6 classes.\n        2.  **Update `emotion_map`:** The `emotion_map` in `cell_index: 10` was correctly updated in the runtime report to exclude `1: 'Digust'`.\n        3.  **Adjust Image Display Loop:** The loop must iterate only over the *present* emotion categories.\n        4.  **Fix `plt.imshow`:** The line `plt.imshow(img[0])` is incorrect; `img` itself is the image array. It should be `plt.imshow(img)`.\n\n        **Corrected Code for `cell_index: 13`:**\n        ",
      "extras": {
        "signature": "CtAYAXLI2nxFyuMEkZNzRniSFpYM2eGFQ+zQkxljI8GcVVdsfYkxNYgSPcolHRlrLyVqBARtLHWpLTfuJUj1NU0QdO6Rb2LTKi02g4yOAqs435Wv8CbweSfgzjH/UQTQtJoMwETQWxqAwC6XGXdpOKvul0uCFPQZVURHYnHz75eD5lFjzhCsGAJ5e6eID+vasOBSYc64LHoA9mcDqBX2YSH8zLgiDtM5NewD+CnUMlM/sboLXy45m8etc6VbJACN7vlDEvX5McM31KKLx7XAe8ptmWeJ6V9wj7UprboOZB/VGu2JK8dkb5hd+nXTRR/k/dlU3YiuMPADy5dJP3XhP+vEwNUYZHhPB2Ubv+3OhcE90sepADOH3u6RNEns3EUJXQnsBL9obBEg8c0/YKmboDJdKnbWbJTZc/HQmiMln340+6NMTnNd9oQN29kZiRhcrnvT72rHbUZDf0xF7DoATP6Ybn4VywlfIdiZ+7ETVSTwtbJ33f1CHAXzTP8Z4hhkity9qYslp3mQIbehos8MelV0L1AjgcCFNEHVCnAWQBprG/ZTu/70of5GjzggkQm1ogd7D0Zb0B9fQe9XWIGawYISLWaWldaZovm4M6Sy5J1+U6o9HyFYoAsKRUCJXta3/VXT+QHeI7UdMaMR07D/hGNFebTWQrSobHac1zafMCPkvieMRzyMEDC0nwuFw8zopI7aj5PBhKhWqbwf7VBGzSQqD2IgzgkjZqMfE7pY6n1Fvpz707HMIj3lZFuEFgcSTNX3rSorMzKPsHoMbGnQ4NMAshqquuqTGyhBMg1h5qGEJSluDqQhY5gRYGGyf1ttInG5f98F+tb1GcrrDoHOGG3sWAYRPjaZ7Nd/JmEu8MAl56NusiarSZhwFCJJnIICgmVCjS3FR9fd7ZHc/xpvFGvxHyOXmEUd66J6/+klwelMAqxqUg9bedCoJVK66JGewQDMlPsTPs+M56zJYvffKvislORR+qmtMht5DGKZ1PbCTQayFVg4TWtTECKTNKJv3cXqGrb6eZUqcw83urvnSb+IW5yHO6t6iEgOS+dcSFkfmqxn9hl+ceK8fG8nLqXD6qEtsxQma0PxYo9HzSD5xSOmuVeA9jLqZeBWEotWkZydu1dfYBBvh1HGYv/wl89ZjYfFG3q97BsWewkNAZ2U55+9qr4P+feD2uDBMXjWv2fenk3hNnrGw5am7FtYCnuQRWFy1UTQAdQzM9aVLoHTypSfvedonYeGzQGtn7nClQ/0A4piHC9w8ojqFPFGxG9rbIySxBCt6GTatUNRvgxz1QG20OWftCZLqqPf09H9TH6xFMJ6+OCpDbwp6uTkg6hFL1I248y33nNA2cScwos63T+KzbdfVbPJU+km7qwWTnqgQErU5v3gu/CquwK4mwCuEOSx6WZjohlvdd1uRqW1a2aINSs0vsdgTdmXf5FF9OR1YIzjdu4A1SNNisS3yvAr836zoqsCaN7TDjr0jTQTygDYgsO62F8pxmy0Uzoab8Km3RczyxD1OtMt7y7rULpNFPXgiusDX5usNTqxqz+4PyZ5kec8KDGEf6VM6PdSF1hjOMu/vzcrGpqsj3tVZIkbG3jtwr+iwp3v5+m8vBhUzxjVACAt+DK/fc5Z8ZGzT5pvhYjhvuuqNrnp45+l7Uj0Z/BOI2w99g/WBZ+KkzIbnz4a7UFQ1eVZLCGUkt0RGKWzWtf84PqUMwdAKO7hNGoKnoZhR8I/QAXuaSS24Ke7rBK7PQp3Iq8HmLmLCuzjL8m5YQu6c8VkkWus1aRKcLIDoKl/2KX1QvthCSysEA3W0Hmnu9oxNahPGox2yqdBtLJP2ESWkQ06aV70YsfkMwOCnBJj8TnzM11kxK5NIHQ4+QQWoLO+Dld21bQWDKcDya3WepTeL2vaIDltSTUKcC/5+NHlxqZk8dsEz1omn0U88qzyI7NEjhR6jzpuvlrTv7xbdk5zbmt9n6T32z0mmmHE9uolLchv2KTojqjI/sc8oKkyaRjeRyTX2Rxg++Jneng0v/K2l8/6a68BDOaMiyUSpucehamzAw8ziXfUZOdDblr4wIn+yI2ZIzVi3IGMQeFNJuriwqHrdaMcDBOgUIH4+pKXTP3vyIwuz15mGBe62egd41z3R5YBrZkOrb4R16yDU7TddkHhNASz/WU3a6manm9OjBRYX8D04pdkawtvzEmgMouTYLsn4x40Q1OFcILpdM7df5ze/LH4grCRlymbYzwgumK26d7oLrEZL+UBYHkXGNHOfTR+sV1+VL0ZQJvynra0UeIvk08dOASJZ9tKgNdHe6FKXfaILEIO0Zt36Zl+uJJyTZnnnKC7ytzUY0lEkPJ/sM8Dz4lvd+4f7irfLdhNDyVZxpktMPc+CbX1Z6ufRQwsjN+/Bq2iJNeXy16vpi5WpZwTorB4DlrkqVe3JhWX2cXq1ZHEZ9qAVENvmImcnl81XzklRKOMKvs2UUgN64dJgVNusE7rjfPkx3vXIEjJ9VC1RqWi8RNkuSm3jbPOT3AtLe7Fw+EV71lBcN/9P0fjnSNsz6SY82JwCJoCNDMsjGlbptPJmpZs/GhV+o997wKyqxSM6Wcn9WZ7fK0UhOoB5QQ5zVh8nZ2ExmT32f2THT569dwQIUQ1Y2YdXdzf8fji+lkKtC0H3spBv2i+qnsABf801wH1STP9PaGWerTJG0d1cFt87xB2SYeu+Jywx5NUKC0wFFnV6cUUJuFfBjJxcq6GxdO84iXMPUgNQ5ewBrI3nDaURTFWZAn7LjGX1P7+dSD1PA6jHZpLt2KnSSTz6WwYQZ/Em6CqQf4/ZjtwDq9iO/P9VE+adbyZImnR9anjyqGF2zOJJS+YS6WuwoUi//XwyruVjRPXsQ2XAH+Bf3CTFQd5QUMM5Og59nP1YCK0sKhsJA+L0tBz51KXrsudZFzsHrlm9GDSmv1KZkxVVTVG5PzKfTUcvMsEc9iuVLZc7fHhYAehBGbAmIAf01LpLzkDlcFBWQLOa/ocxFszwSbbnm4St1yGDRDqkmhjcCyK2hpD7oKECRw/3BygWJTUbp/ZkXOhCVnOmq0Hld8pYNophShdQkD/0T59pFLrIeICJal7dzSH1gPHQer6DrrDwShyIW6vrw/g80eOyqtixuh1oe/nnOmWaBzo53xfEs5LKvl7oDyiB6IKH0U5pGwDVZJ9f8OsVOKhPelLBSnE//9p86KoJN77qCkoz6tSrgIcBxTYofEaorsgsU+SY6LhTMzWJUJdV5Ve7D5XdqO9gvRBAyGEGZWUNlRtWJPTLs4kvkMs5PqCWUuGGfm/rypxJ6N13co3/IUulGbNQQirZX3jbpK1Pbo8dnjX+p+hfpnhzCjLqjtG6sWVXqkIOgpPBbcnjSVa6FzU5xvrvM5ZC2dLHNz+EwTCDPunEOFXK/zX1g8wKez0cAKuHoqDSn0iOewkHYq7JcChPx2aZirJn/KQmjL99vDmIUWLmqhk+QnycU14xNRXnPQa7BZW0Jf0LE7QLWCQzhhWKuGaqpGy/XEdRZ2g9tLvNvt1GRPzuJu351ZbrXl10L9vKmO0rAOalGXU3j/RVKrFqZ2vZHPwRy2VqWQhnN0eyyHCsf4qbC1S3wDZLFbLJwtmS/WBB6TnAVKhCToD3x5k89Js8rkhPtvbdQaIrQZs2i224hdDI0XMxGVI5VSBuEpHwCQXBef+n1vMeb0RvJHIPOWtho6JRg3nNZNTUHHcuqbsRbWxIU6D7Up79Y0K1sQ6rhWg9hLsFbcGGC1t8fB0F+zdlYeELPSLj65bYZbmfXsi6KtmNI3z5XPxGblohUp72HugI4eZVrgAUuRAboKc92Nj4U2F8Z+aMSlSGLfeqKd4C7tyNu38Bv5v+/GBrQ4uRcGOYF+OWZ8Y/6vd3L3N4yIX+E/9Xc8ytMWQKK80ntDKCK7sce/KC14NL11Zti130TXydSzVyNHOWwTViZL6TFkZepqP4yM41t3QRbo+SJZfCxB3qYo05wh5o/E6kyyR61PfM9kwZ4udjkkvmXn6E7aRP4aYrPg8uFaFBj6mT6Sm5Ub6tSqOFh1Zbf4hSvF+VujJfBehG6bHfdUFC5YKhiCMyNlOH4QY+cxESU7huFRx4poY3RrzcMDb/pAKnCso99oQ4g7oyOFnDPoD9kV3u9uORWMXeIp94fwJzbejPmwYN9TrNSTK95mKLp5owsXzBzM9r/UKkgEBcsjafGml0duD0KOY/yd7vYccPNAQANJ0MovNUpBWjYrOdlzk7vXpkN3TDoun6b5gvO2C2vx68VRb3Fg22JbxggwZ5Jkq4v5gI7EfKxBZdS5m/iyFeY3i3VOl+p0GAj3TBv920nStuI8XxwAtkWepZCljaiW+7wZAz/FR+zuy+t9clCreQp5F0NbVCzXivQrYiQq7AwFyyNp83KEAvT9cPoizgl/MAOdGOftPE1+ggK3rrkC00Ob0YVfRbf0k/bxwy73vzf2+fwC85oWyJM53sAv9fhBBGkF+l2lbSmWMGSmind0ofaz/8DnkruaWbHXrXJctk0609wd9FyA/IwM6FVOxHKKiVXu8kwy84YwYVbV1f1yVS2D4M0XVTsHDzyrM87vrf0d9k4PvA/5bHMNtKTM4UtfrhjUZWl+UxKefWPwfaqo9LFSDoLs4oh6khg25sgQ4xp97J7cfeOMyhYE/dA1MGrUNbXcpJBJsVIeKLKkogvn2MeJXUMpM5isfCvOGqyuT/trstMmYlpZk2fiD9HAXTXog+edb07X9F3QJg60I7oxFO0JwY1LQuil7OVeEwMh0ImcoHUlZTDn0o6Knu1cwwwpuxjUXlWjYeupH9FvaFbn6YZT/5JR7O6Iw2iBjig+SbnEnwCMKIlS2lm2oi2TMXp+iW3w4CkJvgxtwjs1NyDYfedBKm16KpgYuMJLfIoadXiiW7Umw6QMJzzmOjkrLCnPj3Vtsf9zSJJnsXNYwjr3+HiN7df+eLo83ZtvzWOYxkZ4mWBChLU91Woi2CpAEAXLI2nzgI0yOxwdthYYkqmjcgqaTeilNCZPGZJD65zQb4ThAv70fPXJM0MWQwUbBsYY1qPEjgtxS2tTmIcyUYFT7BVqOIWoVeH19XKLBDN5mnolvUE1o19F9stX6yhhEpD/xhmnruXgbtIx4xtsv1E7ZZHdKjbY9EtcdoPrcDs2ADB/aUWSt3aFCJypSFRSJG/oy1D/Kxpska0TcfwoNipDl4rGZPzXe88fWcHjqrwh8McYZZQyO8sHWE2NLVhnDisuZbQNezaD8ZuDTUHM2HWLmFe093YHyzRTLzzXd59tFEVSjHQFlUbIDy9mtxTt3pJ4oCfKb+jkwEfo+U6H625pG3BnSWfocq9Iu10fZvaSwpJwiI615tzwQjh/E6Po2XNRhW9yPBHwV5LlzscDAOEMwcEB4FOWotKy37+/FYebQ9iLq9mhfmvECMjrrSGpV4c5CQ1o8dEFqYlT6Lmk/BJH1NIGj2IqNDya2dgtyBnTrI94Fkg5P+rwtXhe97/qsZwseU/UENI4DtJcELHCqp44k1xa9VON9aBNZuGGhalc55HOFO5dIGleESSRdZpawUGocz9/PHHSS4/udDhLfp9WGvww7TZbbPgFxovQe8h7wdz6i6z3TD7Jnyy6eLLT+ynLljKp0QqkDl0Q74KBSCVYjdyZ7erTFcGCljkkSCbG04pO0iU2oPBg6qAnGzYCrCv8CAXLI2nyYAUqab5yamCBz6zsSHcKFIsF7t3IL72zbgva7uvgkqvCvmCWriT0f+F0WKVpzYqSN6PxgyJc7u98f6nFFhk073/BW1Qm+wkBkZGGoaaJ8vXcr2vZvZxRJMZDl26Xza/JDZh53+kW4rROen1ZifQvsXwOi/7ZnccFyGjC+Bf0muqL2bHoi2msNcoHEKzVU3CExC8oLr/4VDgUgjhjmPBgiPMdZWQRFQQL/ifaPdG7VL5ejjfxtnKc9LONhc+mrqHNqhWiAcdjryj0Q1ErjIZVbk4ArVvoHXWQGHHnvpoILUjXAA7LH0k3ep/X7o2Trr++tkPmOcz49Kz0v5jUgrMFC3NuERNR1zfbuhVCgCzswt26sC9w/w3nLZJ5fM1jMP4S39dFIj29sQuXUaV0PDKzOYp8zgAHzy8aK7Bh2rEURCTK3K1+BFKtmccHEAYJkoURagGjXOa2qsjlE+POXzUaRYUo0qa9iB5l7Zhl1JtAlnuM6SKxiThLqzLgKrwMBcsjafIwjsSEBg/mIgQ2ezcg55+TrnG7MS0sUUyud5mJ8iX2PL3203FyOtG2qSZUJuYUR1R/gZjeu9zegc0tzED1iMODcG71azXvQUW+063lYdKJ6kPkOwu8fOk/vIJnM+YChDQDDT7cFteySFvykr+iYgC5NDUks/++KhD7pwayBLyi7yvYUEcM+ZaTQJcOChiO476oNqpNMlQpfaPQ4Y/ul1jQeIEQn+QzpU7wJZsSsZ19nCUphVGw9C7Nv01C7fHa8C6c8Q1MtRmSgRunqKsOViJx2Ajoja11nUvGI01rjudzT8zSyYSIsIKMnRcNgw7fkdK9Q+FZXrju38LFy7dnPfXedKPq6V99kEDX7RkWqiH4gtNnd5anJy5Kry5hOdy7AvkAMisd3nBWNYgbPLons1/6YdfI64+I6pWZL1Zhpkk/KiO4hSbMTMcGtCXlVFwv7m0o/RBG8tafLUg4WTiIZz+wkAY0QB09pdpYHrU0lMKF4oTl/D1GBIupg6c8jFumWIqL32unJHdgUNpbwQh0lgtxnKdJDzVSXDv2lCZnTp6qRX9eywQES+8ZarQpcAXLI2nwj1uIXPEbSu4AeLO9aepFiJALOENs9VzUDXKDrnhlz4CRuA+6DHa3q3WBeKs+eMaYgPA5e8HLENk7eXEHoUu/RboetFXNX3NF7I157PvFNkEGH29a/agoK7QMBcsjafAUiKpF23rpDaQYulrcqayecKVPfAyUbKLHVbXTrmq/JjcQJ4j/ySl1H/c9SnlPNdqxxMUYPAZY0Dw+z1jIwJetqxyeO+925Uho66BTh5iHyvXl9cuv4kJuERw2dN4lcZmgfXz8MBlobQUeJjo0BTwKsUsBHtqgH3dli+xER5cwdiSJ+RAa8ZNZP9riAtM2jBbURw9HGkRFXwsp+PUh+UP0FMx7PSaGCxwlscEy81zf3Y2VBinUP2u7vk5/VdMiMo1de5Nn3MrNd0vqAaFgH/ZVn14zYq0W2bDLOtk1UjnFBpr4MJpa4TAXC972dWBaExBUvOCoK+ggywrqoHbw2hxgl1ditcf8UxXkNHyMT3Bp1kHUpz9p+YUxCaxYugTfgl0E2lIozy2FRs0Ogq9TFOO/3gW/mtl4s6fmItD6zHHNjk2c5kagNSreOIbgn5vh0pk3nOOpfxSHp+jEM9lC+Q+uq8PPr79YqfRKGceQ0tuqHNyUaOh+ioBV34DwzCNnTuHneC9q1EeBIoMZitmpupB7E/X6uA4cfw2egwGSww2LXyCcr3tBbBAFATvxK8cu/oAmlEc/WUlkRug3IH59XLZkAYejA0eoPwNwwVACvkTDTuM9csTmhV9tJorp73+DCVX/K5mgo6F8gCucCAXLI2nzCr/f9pqwmvDLUWgJTjCFoQQWSJZh91DJgXu3EjR+gqQUC697HVf8VKALU6ZTrgvmWXYdFNRaadxM1p2UrphF0IN02cJf64v4DpLr4c0CvZqyfp3UyX3PR/Xbdz7rJTq1pmz3zbjyU05zsQHHgT0PMvVicQiDi8No0TFlgygcvu/ZJtJJMG1Ipu/t1N4BYiSg+bwgboFDyg6cstE6t7WQM7AU96mTAfncIcMqUdS9wLwGKev/ccVaY2pdvt0dVGVX/SA/O7ydFUS9SbLfQuh8U/CVShaSgHFjdf0oLwFC85C2F85+xjl8Cx2SdRCNv6Rs3Q3Eo0DrgF/AbSf24Qn+ekq/4hftBELPUFZ6lgZlpeL/jrv8oOAbikNgBqe6wtLYOo5L6jJzsbgHA2kUeiw7nuXoaUYdZV3P458Ute8s8vIhz4k68Vgy+xxqsKcZdMCtWoMm0ho7UcrD6+bF7V+IkOr8KrgYBcsjafG6YsztnRLh0n+Ek1gruONQPYNcj79M1jU35fvrtQYZ8SrBUIdRzDPJT2L2bNaUGWoC3QEAMWunrOBF7GiAKlU97Blmn9j9tyJXmIKGYFZIXkVeRCYHoLasEiEDcgfRoL0PgkYwCCrC4uJ87tSBZOCLAqMoXhmQycKsKP0FGuav7guQ/YV2k49ZaWExgLyvR8XGuHdTDu4QSrv5X9ifgh4c9vu54O6o1psn1O3ndhnjkRLhLslIMNe+0pTlS+n4pzo5fu/NdivN8vQ3N1IZU05RW+ZExxf2W88vplW1hEhCMey5GlbGYNxdWdh8vMvfXiniHXunx5WGmfx9LEJA6kw4o5PeaqC1phXuprF3HRm81NiwlXAFANYynelPJgBaweJ5CSS1OZhIDjKlf5CSTH6k6wD81rCoyOWRbPBC1Yhau9Lx1ruzNMdney4xh0MxAuQQDn5RgSeCRG7J36Feu0ikWvjv2tomyvaovdv29PoLR5aEQXeRhllD59RX3A0bKfAOWnhuikJxnVSMx7fJ1TQqJXusAWxshH/+wUWofmG+YWbroP6IhxzquBItcXrVttWratGMJPUoHos1cRqh/47xRTfn04qRq78ZSFiWDYvHAdYTFfxeDBr5UUwVNYqaGhdhINVd2QxYXjEKtrFk3qzQmileL0f4R2YpAbuxp7Wez2g6Qwonf1WgbTI3ohRqTCgku0eVHHEPVrwNncqx7tOq1nmpN20rS8/TPMSyfV1BcdAG9vSW+56tX5p5FpqdwC0xyKIvvW/TzzcxdOVgr+MZPq+27nRzNVNjAxC40JSFZ2Y+PxjBjPLVhCkD+Ub9SLOE6407nvkN62QcCmvkWJmL0Z2H3Jvyt517TE0bbFFxoqnFmkqXCXcjt4sKN/aSPlS915TrS1bXTR85Jts6wc3X8CjLMcFBPEKbMYRtisvmWIcFSgINmxKwsaIpqZD2vAncOjq6uVcmgkjjFVZgTQHHV8C6LamAtjxDsAfDm4AVJHBrpQj6obGr6I/DIbSUP3fhudN5m38UDG/Hl838OglbsOIkSmtdsa3qQ0ydokHx064gRS7r+a6q/CowBAXLI2nzvuWGWDDL2ZK/HbkHcmlhxIARGkyhppFvXR2ZxADySh3kuQme+K6408BUVFeUSQuwelD1OzM25afR0UH/EL/boRMrwMWIzmaiQv6305RTKHILSSYEsToV47Rc/ULMroniDbY6WcZ7FxqYLCA7p1P5DGxuHkOn4O1J+Wd9F0A3fzC8qqZsts9wKyggBcsjafD+juZglWBPpLOXfn+WXe0Owj3Mny7X4DcGWrQn+hwNlewPhCu77z8CvoocK22HRFU1jCF1rZjSyfFVh/g1daAcvP4O7WJEctZFGjO+MTXf+jLVhwnsFNGSKLRfyNZfnhI7hsLXNEFh7VYvC2fplBNKcNZFKi5UNCDztjdNFXxFSrpARj9miezLMXVDV6VRBLlCXxCHIWg54n7elZ1VKeXRYrmyJMVjtLEEERKX8KXHEdcexDRBhm2xAvaqxOESqpn9MbfM1ilsWWe8mgKcvXX3fGpwjB533IWqCPAEf10HDBjMEEJQQBvzdXkzuKz9cElfRuv4nvWThaG2m8PhIYiASBVBd27uCS82petZXH7zHRAMaXv01ApaSMAwaXa+ynxsec4dfbUqqGTdvzAovfGZBPK/ZOHVMIiZ3xFtASWj8kfh3OcLpYnRzrWM0ObqABY4hUIkQJY735Varcs4NqTLUVqL6UsNjCZy4ulvr1cBUv6GMnQXs9JCNhz/FycsQdfaiNyllKhDz2X60Hi5zl72Q9cjZAPKdoEozyjlRhhQPAv2YvE+smDxydbl0yWWgT3RXrFE2YFHAJe//2nnOkQQaocH/j2ETDw/UScyjJOY4jcU+dHRrTMD0R4VVmShVW8sqa80QbldW33qEGzP2gKfzlIqgFnsrkY5hxpllHS5Pk5JMbkuyyjPYOSuLaiYLtJ7FI3Y/G5jktEAujLul58op4NKXZ7O7pH6Yn2MEhCa6OWfjppLre0Q0EcAWEipEM92VyYB2GJL9xLN+TGLHg2o0yEPGCr+NBoj8PgLmwq6p1sFNf85peHBTElLSphdHuXWYgg2UYWKGVht0m2+3XrxkBA2+uvD6q6XCUdc9f1Q6C1DjJFFdKOaCrC8q0Y90+D4Cd71SDBq+1sCpYWUtKtMcKO1/Zmv3s4YVaLj4BJ2epHzMZWGCF/9hCF6g2OK92hGRN+sGT7xGmbuzEug69LaLkyrRKdgU1Z1MIEbH3odTIHOd/Yedjnkg9mSTgoJKeOZIbb6Wo4DMM+93V1PIzXm/qoPK+L8Sh0oJwXODCzJaJDsNBrmywTsyVMT92DSpIaCYpRKTxaNLdFZ+9gueFyqTugIxeudsNSVcbESveeiEoekRKVuDg+Ui5jVnJOIdo3Y2NjQozdKIPoiZdLj/lbno5uNlTvH7WxD5KeCocNBwqrujuRG1Nn+C/qWqNKeOG1Ud3zV6bU7xSE9OL7K1Z0jIa/NwX8+wr1ZCXMurZm6ut7T17YrSu1+0L2dUJg3r4yVYbbmns8Otkdq5Zcc0GoLWoosvWkS7ZAaz9ruHOhXRxbQJ+4FEsJVwk1Dwqub1obRXRRhRyNFT/6/VUpE0hHTNeGgOxB5o1mKOncXbV2iUZvBAsmzj4pQ6AOoadvFCXSJdZXJYs0OPig8qSDcTi5O+teQoCeJpbvlzaVSv8zXkaRa9rXQK8wMBcsjafKAPHwnSH+eaJ0iomVHWkGkrpdLlU9t4IqOaINtc4Tk6yn2T1tDF7Ct1WqsRRRbZyqq7gU97UrrJ2Pck4XPlto7Ub27PBhzsnnlvT2e2BQNxUN2okW0JCGOeWK/QHWT6JhTq13sdT2dTfyZd3gC+tCw7RPJkJoQgXO8S1CwqvlYKRP9fEmzSFFFVJJFLpYCcNcO9krfTu4xT+XpjeyNQU1dNEGw3Avf/WSqNwmhxqucW1+oaRGwx9OaaNc2XI5cxNqJXjNq/afjpgHFBXwR1+pGuScIeZ/2GT27u9B6uqM28u+XOg1Bmh2qSAcHYhZHCxIJ8vPVa0u1V6qzXb21VIn8zTsxB5E/cy5vC3F61WyZ6ItomuuMcRM2zPfa5oUk2gcgpwXgHMRxtgTuUIcmhtpebuQh8Z8P+5yjRu3LBx6iSLCCQJzMiKo4wh4MHMgUjVx76sVp57aG5+7uHpsiYrsR1HPW+6C41+XfkcZSuuitk5zMmRUuAVHmgP4U1RqkBU8BFGuRIEJlpxuRv0tYa1Y1q17vMpcQD199Qh/mhcuHdvfzktPvH3j7gah+9qGyQENgdNr04CF7M/75UUiEYcT1stiQqo+YQCRZINgAk/4wmFhn8FL4cgDZCuK37c+Qk3j7TGtgOPf6TUtrhsOr2CvIBAXLI2nxYsTsloP8sUdpccr96w5K1ruRXT6EY0bzFJpUMhnnOMB/tfl0OjnvZ5q1A2QA+54Zpei1HTOWY9TJmokcP/WLjgQ3ojY31DvnSpNbseQooyQr1AN8WO7UfqCtb4+lHlebh9bm1QnAupWmEKiXekNeJc1DZwgZIe+H9N2iHFC8QEbUxPk3udX0wznstRDOpxACKIqcC3ZEr+2wg9F3ZSsOwj4jjCi2/PzYtUfAFRgNLhphR9YQPwyiGd0w8rABuoVpmofqxmokICGPyMiNn1E0gWZY5PhMIqmeBAEXYtkiP2n1kL8eDf5djByY/CicKXAFyyNp82Sr58P5DgcWKmdDlLs/jAdpb4RiTXA3WX85fXm0puf6/0rz1X0qomWG1t7233naQ9QAs0K0B2T1cRXWVyZdWgyatScXsWqc76R68JcKaDRnJU5Lfle5kCqoCAXLI2nw3LRc1q4ffVUqV3DnhZbh6iUnL0b/hozz0Y9EAf5pWQIqvzGXj5mS5VBXlJ/OhzNdQetLUS2OSYhhjJauJcDNKFV+r+/c1ULLMdKqbXAUNTzSwuPm8KJPmdLy8zdQ5BNxp1KhJgcpc7tcKj8tVXi3O0o7d99r4wn4stO4rRp7L1tAdsrdDSXiIK7rJWKll1EbDHoWwUJD6w3sW4Vdy1wSo5B+1PRKSWi83h6ao0pD9jsT4hq3mo2vzMhAIGFA7pT4xTeaGX+EUyk9Ssn7pTvOFgr+pVQy8x4Jstc/fnmWq3JWkl41FxHkKxhTrqIGMi9xspQAzpU/Gb28EfihaEqemtTDEUz1AQUe/nBlxup1PNdrVf9GDao60xO9fmASnKKQNldwwVAqaAgFyyNp8S/7XMNardatxpJ7pidkcgEu/4B/MvIWBicicX/03XCcA1enGO3Bs71SXIl8byDbv1BK5Dm/u65EQUV0fMjzXMiNz3FYbvBXRxwAZc4XqTmGSsdl4Ol3xh1LrVTV41CLQG2pVAMFPoeewATzi1uwCwuXJ7hLhub8iwoT6f7i5aOAr1k6iE1kzLL0hx35ORM1eiNtGrN3RMRunOy3lSYG5am3/AccqXBcb3Js+u3Gwv3qts6sMnBJpN96KJGuP0zPU9PjnCewHudTbcyMYAmSzkJyXPx/AjRYIZRSdApVGhOzE69g9zq9ZLPTNC6EcSDsI0i9i5iS+FJUyr7XP/b9cMBMDLvb79JDe8UlBWVKfvNMzMvBTcArrAQFyyNp8Dls6iMpQyI2UlBvc+ywIAOR/Jc49YHT/CQeVoGTAqW2fbSb2INlEU66xuHDjUEUJAsCb/SWN822djSDRdsxAfC8ZSVG8VkQIZLIwBl3SO00J1w/yMsnGPau4Sus4qqNdwF1ob2D1X4+Wg7JfvKD9AwnYI7sWXhwbeDIjF8AkJQYDMsRIubQ13tdTtH8CAhlCkWr+QKjqYa+r7uVPnnIp/Huzf8fXfPQI5ONZLDn4TFJE8h/3uqHTj9KePviiXQmjaph0DFFt+p2sWZkvvLZ954/HDKIHiSafoTg7LDfFzV6HW0cj850KwQYBcsjafO/bqHx0qUawigkZFJmSyKfCQVOdSqV4a2SW8V9g25ylbrpgpjbd7T3Nh0o6oaiEH/6208jwF48lvp5QOeqc38eQOZZNTa+pPh5B007fExiAd4BPz5vPiowaEpT7ZXhc9iqpj2A9EiS5uVW8mPUHVW9D04RcCZUcuw25dTa39oLFGPb4tU3uq672GJ0JKablpgI8PsHzJZeRIN8KGUdOxCWPDNkvR8ETlD9ykgQ179Z3n1cUc/Yu8WX+0p+3z1dsQw7CVBpQP9qE1RO5otFk7paGBQkPYptggxX70rq/UFIC8I4HKWIIqRs7umTlS2k6EFQPcUFu184A1XA/Dr1hZITSXxSzuphH+plPOX1Q3k+tGSoO1PQpIMIEgwpISSHkVDUpDHLALa/3ajgoTSUkcH+hvZ9LHYEX4epBWuh/l50thh4cgULCCc4H8Jowo7iN6XAYw/JYmTxXJIQzg99MkUwE4OcEiIpykcNc3LExNVBYpRpxJjB9nVeUkHbzhydc1O3w+W/XBC55h3SdaJZ8yluJp2BRPS85I3t5wXuL9DZ4Zi5MiKf4CRKz93w7XkytiyEoIGE+WXjS/vaDWCkEdTbng4p+YIJ6pNOavwSjMU0CnZ+6k/5wNbWA/PBThoZ4i6laEdUQ8M79XX/M0SIowxFc+LpQI9lCWvuXon3fMFyoZ79rdUqxQQ0PXRGnrpi2Fnj38s4ehB+rXKDw56WqQ3y9mWG98o0lCDht0LdDojXKXOKZaP6FoEk27JyWCjDzF+PjOiDZ804MqZbotdKqAgud6AIM2UJ2sBOnB7t2KgP6HPFzDS4WIO9GnhQ6rj8MgoLMF8zLRlh/dJn/K0toBYRkKxzwTgLdi2skB/2gK7J7sGcvR15Alglji5+MTMcOg28KfGpPX4t1YY0Hsv0AY8+UuGJFb9G2mF1BLciEyZbqilOeIz6PuUkf+cDc46+TZc5vcPSAcCftql4y/feARCLcQyNUk+/FX2Aw4ivqaiIH50QuoUs5qLl13OipmugWwPaJ2mIgdbY601ZntRVARwq+146VY/OVFfeJY75k4AeSdJtnhkT4ciPJqhGuRAJQrtnSj5qUGz3C1/CT0QqaCAFyyNp8ArS96nn/8PRC6qddh247NS4C8i9ixesJYz9KT2S9y1q3RcbtJAHzVXXO/MXVE3qUWXv9vLn30At0+19yOwrFakv4bCfuVPjQlFX9mG41NA1HNLJW+RQAgczlTRy8sbIJhUU8sHlD7xgNjqKGZbpsGais2iW+MEHod6hbwV9uyKVy0UN3Gp6VekOYkVP5pfpG38jOPAOODzxIaRuVmZ/PvAija5m8xmsLuiP00smJYpmUyOVlQOz5MnljDnJHdcF4kWB9lo6IIEcNrmzaRQzQp0PUlLT/mJ5a7WC1POBS2UjV+C4Sr/9hIul307aWVdrT3LAKhdqzdd1fsgdH27Dyesb/16/f04SCVkW/6/ZE2UVrElImMWryRwKR3xX8x6WWoOKcwLcQ66rN6CqA0IUjdODPg8W+y4VKYgg0jiKdAENYDStpLjpT/hAoDViATBBimO9YarMjRRiH1lrYS9A4RvZTbx3tO+Za6uIDk5HG5s0DlFQeUxNgKw5YkrZkRVIVWhB7AdgKbbxJJFZM9MOUfbEs1aGeDRrgJiHpHwia+BBK83X+iTsPtIgV0qcimLqdL2azcRdQYc0iaZTbROYI68Ba5aeAsPQ0Si5/+n+vAp7Pp15b2kbvK8PCPMKFN3n6pAJSl2LHG1BYesMqIxKegj9mfwukwav0ThpOHT81Aes8SGQEYRO3lStPdxqKWOhBchuwx7MvvZY2LUavf0sjTee4zcVyteaIdoeS5ubVmIS7TXZ9KpU5AUagfuC6P1naEJ5Gol+kFXxTBfXHTjEtzDdBgGDQFl04r4pAVonlZv/sqqg+z3i4n5vVOH8hNaztnXTQhWq/CCjVfkqQdAwnyXT0DMs/afODUpu6iJmn4kcCtS9b87i+jW5PBvqTrbM69SH4gRG5EL5P5AHkAKrerfWLm/8w+YBlI/8wE1Yz0loeKn6W9l/cdqj5dl1PGhJtiZVbr+xT1DMmEcCq6m96Q1ZcaSAK95cpKTLJVUsqS1wcZqLUcyVft73+ESz99mfv7qQeBPPH8C7nn5rSklpK7952px9s/DQ0D0KWPqxXKKBhfguTrXBHhDLU+pPYa544ufcI97PVRd2JPRvO77/6ooq7e7Kq6ccvbNn33xu/XzT9x94obSUOQGiiL30An+J4oy1eo423voBjH/v/eZgOI8XorzIL4Z3cRrvoQDKNHVaC2/S62sXhZlF8srEhgDe9t3J8uzASvXiWCAIQtdUBaQG7gEF9sFk74MFWbOFxvZxP/9Au3SOWI1BzS3MiHlCBvWbEWNXIcVsECZUeoG559TCL6sYTa3UIctT1yCepOcfnXj9r/m36mUUQ1JWBANicgRqUFAeqjMM4d2xEW7NG+uYcJz5zZMEp2Q6gMU8p3HaSU8qLpgqKAgFyyNp8Voku9gkoClODF/wSh5zz7EeHLqr0MsFvt3kLTvtHrGnsA7UgG0THnDuLb42+aKgf71Fwd8mWZFwQ2GnCFZCl4KG32dVX4uskNFsDxJF8iuQozi3Nb3wRo8Fk5r6ajuqtUSTb5G5YgiDESsl82l61xRXUrCkd9/u8P5+qOTKpdeB2+U2YseK+2m6a+332JfdXsGSwvhGjB8g6y3NLluOh4RgrWuTr4XFhxEY6UUq+Y95UC0TbrZfnK9YyHMDqhdHZvz+cehL1iUtg27OMIbsP0n9Iobl2bCydnLOBVoTjOI3NaCemdKD1aCpC/O5in/TMtm4M7f7tRa9Guu+tZ6wzIqZwuhadCvgGAXLI2nx8r/qwT4cKazOWiyK/mLqHprxd15JZK0oN6fvS8v2MymhShW4NtF1XhTLgc4jBjUsBIOfXs+iGWk0P8036lf+CZSvVeXQL8eMA3Zz7DPnKUy6OgSjpy9hdPsxfMFDbXQbfEraA3G5UxeP2uJJiJ/7sCJC36Rmh/J1f/saU9kcnzU2hOESURmsNiUCp3ujD0TN4deZtxgqmssw/1Qb9+guZA61v7WQ1A082+/3xX8RCc/ySSBqMAwh1aLk/aEdPQ2QU2bNY8iva8ofTlk+C/wqkyMHSYSORsmpFwvO9fLrcyQK63/jkrdTf3OqK2JoOt72o6R/4VyWiN+NQSySKu7CeVdYsvzMN9mEo8SeKwm+0B68johTVqkMBPWTvg56LnB0zG+NApP9M70VmSUb5X6v5UwaBT6ojzTpgwJjdf16cufuHipSC1NTBx8jOP29kfNFS6K7z7xKQUKVE5T3keoI7xhD5ouxS3Q3fubiHhCeUEdZ+DfAJsbUFSI6o8B19lyMY3TyVVjMtTlyVCIye41NbCkUmp5foSxZOiGOrrfOnJeNP0Mv2A4xye6BbnebWFryC6d/cc7eQbtfk6/XTxQGUSbyMFgz3mqv4TgpWcJYsQ1pSVc95Ws4R0io/bPysrxTtzopHcYSf9vgjPNVDrF1Abdi7OuTLLyIubfejxV6ZDNVijzFprC3Cj4QDrJc/739OrWb6+NtJdZbia5PiMX8UbxbK5juUSmsy8YF1VBFO2k3rMuinUHFDK8H1KSekXbit2bJTaqHpKicyxfOoUAWo+Lm5qK66ZeQ7Ef6CYYcGlhNcL9U9ffSGB7NXFY4QyakfvWRcm2wAT5JX8m2rKEhPHZ7Mn18atug193rnnsap2OJoyRawuMjIodJTyKXo3d5Q9fG8m60X3pM14WGegyiyMtHVJOzFd0TRW2qm8KLWrxgXGXBWaubaFl0OvhBMhZxpHLeRMIU+hjqpswrX5ef+2OkYlJnGuCwKx/z+Koq9bVkH9+N3xslwr8IM57mxgvfrq3wnq0IdYLevd8XlNj9xgYqHlZlQMfW1H8ZT1bvP/yfKT/5szGW++bmsKsT12HKUxp+vISWXtTeCAHMToSAWIi1MIz7gHvKyL10bFPuWYY35xEtc3lF/UBJJgx3ToDI0TVcDvAZ8bQ8AK6ZQcTx729a3CsMGAXLI2nwmxMVdjmLsZjFGjkyHDzlfqgC81WwaDSxi6FYyPIe0uW0vh5ypxIjOy+t1iCfBub+DJXKgxvR8kn58oTIF0Ud/lrdWt6m7RxGknpdtJoUobKJ2/MsjTHiBXOcelshxdqiULS0LuHXbazy1WoZX9NHOJNyfDKAvt8Kf5xXeq+WBrb1Fgbv+UoFkel9seMB0oSBBwmVO98cPZ2nDVkNNHzc4hTeBohgZRQGcqQCRjWlxaXAiVfdph+EUUsyC0ge+4WuYPVWL//fD6TYJZMfoi8u68wX/QRFDEmYSjtmI53y9wZXOIEAFQJXLKUnFMomT5lKCYI6P6iulJsHEWZGN7IN1pkUgUWj8ynC98Jjf+wofwn8HM+vYD9O1g4H+QH2Bgzqm6gOvC2zjhyp3hjB2oRFwPbCaITLSgqf4aCc/XRDR1MwpS3vq7V/pVhgPy6KhEz1Eh+uAX4TB8DaHSqxfQY2QJgI9Vyznp6ZVg5cMfU89maakOle3TUrvz9irCZJJLkJ1dzoEGWGY/hJqeiQbGX14Ikrsg1k8HBYwrVFj86F4QMlK6ivVUFa9QqXp78HcBhDAkRkDcJVZo9UuX2ZUhhq97cRQb2kFqELh79bMkCsH9voQg5iHT4t22ws309h0g7Q99Cj+YG0PPbfv1hoVjyVBDkEwccBzF4LTAlf5cox922+RvPcOYatE5l4H84aoOhimH78dmhagi0EDj+8aJ5SiI0ER+6FnlO4GQMV8s2T3ygC61XGe3GFXln3wKFM02Xmb77S6d9TFYmEVR/ugo7lYZOIKYh7GJgbDG39/U12DMtnISYAkqdBecYxuJ6LyVFP1lvdmg+KJbN2C6pN/4GzSzQqu/1uf5ly50MpDRe0bkQXgwYEA7XvDjG2PgEZDl4wnzp4CnOVc/lwPcnETDjZjEe+1SOGPTyCVkwqRCWsr2nTY7MObBvQKzIQshMNZpmDIy0UIi8JQTsDSjK5qCna8hMfPC5tgyoj51ZQbJM1fXk0NqpdHoFAg+9uDVtmKdKIs69N9hmIhXrnynwrOLdENVZHq1QN5T0pLRnjhdft060cJB6hS3+f6X5Ax0dvBDX+2HXNN9fjSOEWcI9GFwgqbEgFyyNp8NFK04r0yc5DpJyxnUnvS9F8QrDlQZT2UxBEtRkG51xpemiYtJ2Q1CsTPFy1v1l4MSc5scY2w/8yzw2DdFwpp8C3UvCdrpnUircaeWPAfjYzdkSI7tx2lgl0VbE0Kiitwj42jZR0HKJ4Tehyzd3aDo71eZps7qMuc/Ca3T8nmjH9qPgu5e+R7rPOpqVG9rwwyx1L8z4QQ7N4ioXY6M5SVzCreBAfY6ccBWLnDIm4AAypGXAUMANtFkcmu4VaUpygLiJtfbc7DOKvdKpVJp7YJDRiI8lScXencnH3la5MCciiCjQGwDhJLiA9FLSnF0GCLJCtA+2Fu73G4BI374O4DN5T6DjRZ4Wy6SqHw9/vEVQce3GM/d2jhlscX3VRYN2G9x7f2CtngusIafTZCQk3fEIccbsI37Keeu0mWXnY57hhMUFFToAdTqvUR7d/hptfZ29CbAb1So7HJzW7WY9m+AMGRRoTL73HDqyX2LGn5xuf2tkVo++ZLUQu2W3vWWHK7fIyBeWYiATgw7TsVY7UOoJejyeZSac0lmqiExKlq9p1DPHM/0r8eU7MTm/e/wF8W6t4MOmy43vmsCvDcIU8Z95q8AbKkVhZDGU+QEkacO5qtASpK2aHwDmGZz7jCu8GCNLY96+CukG7UqxEeNmlk4s6Agu2+CahQ8lghN65rTthX0DVOmO00RUUYKN1sbv8fNablzDfcKaGW2UXfBdMR37xKKDRTvEmNdqGzrGWETjryX4Dv0uJPnHpaRCfdzfRrDOIDQbbWtFVxLtla0cp5UUbDchR8iX7Aw8SHgx02bYiIPHr9yHa+Fjq+YYDLQq1KsJQex+HBuEJ8+hOElg2vXk4/YjK1Psovuj5CafAd+fNtpu16cPt9uncrlvPIvKw5wK7Mo0H3lgTdst+vEOLk9iKWwRyVSiC6pdYaqrcVwoYd9fgGwpWGJrB+Kc3HavdfBfGCtpIoBjRDZxr2IFNU/gL4q3KhXVTbZWCHRXQyD5g+DbvHnoLzOrzhyyoRtZcuFJxhjYcaHpKxCADt4fwioTlwjn61wfGMRdkn69v8v/r2s7A55od7eoN7cZTl0D8ZKtXFVDztkVNg/eF46DbRNOBaD5twI+uV3oPUk/R90hxBrfMqxmmhPyxQESURyzNKJ8FrWyAAtbJccnKS3S0bRGdumyx283ix8gxT+J9AATX2otnLPf0kvBN5YQJiTPRZfrhpvS7rzHGQLpfSYFp40HVS5D8jZGL8jXrBhZZ9D/zXTki1wf/hidV1Zegbtug1RBbwlUiIf2vEzIFOsBp4UlAiSnR3NtsEhORJeOfHmrdPcQgvaKaC+mv6gCxULlitQICEbWpNQ0tlrDE/F7TvoD8xdjlrdlxHkuONMA/JA5UHt302g2xhjscoGjBV3KcwkmBzRveZSqsCtK/TPGKDygF+6Aws44tfLvMdBLz2F9nwPJbNF4QwppZRkd8rFsqTachltLWLre/IRpFlPipo6aM1YduK2bkuCbA4gdD4el2rJ30g/etLBXEZ2JboWqxEZnV1sjNeSleZWftljKKCdxE0cF/NO4PoZ8mzltde/+z8hQCNhDCFF0qVbjVyJyHFafUHKRvWsNeKsZs7gv3leQJtvdfSITnwHMXheCp28ea5agsJ5usgpaUtD5jxYoSQ1DFXDpQpp7iAYa2wTy1u/VTy9WWqQgZwLgY/xXqzNqDCEAGJtJgksZQkiQEkkVr9zRoEcFN34tVjE9ZdNWpVEYI/V9/e3xUQhEQKQPfFrqPxLie5WqXcie2/CIzjeKX9uX+0FtjHDhyyPSkVGc/6hxMyE+Kp1EmoLsUk1LwwwlRdDx4/dQGkbUeiPg3B8FqBaNTUGpquamM/oTIfG6qYf8tCEM4XQKj8RaoGkHEcyueAQuNq1TKzJK3mnAtnLjYBaZb4N70TiNGBDI354Eb5fnRTtPT3QDunQe4PGpNCAUOhmcW4mqAE6HeUXoO2itEj9+xeKK/eyacikOtXs3bQOMRRrshAqo3SK10TfEYhr4RRKmehnya83fyiGLsbiBFu++XKWwwxrsBJTAqyEw+XOETmo0iiCjUuZpkLZJKWxgEiN+4/MKHIcIijMqiqvIsBPECsSxGYhVj0AdVqdWQTge1P2ILbM9D4P6iGtP7HUnRf0TYTyESx0XFbHWI+j7B/XMH4lpWk2BytVWacqu5DPRm1ASvt+Si8414/gVhbdhScfyi6igNh0ojxnc7WxfFRA9rqIpv+rJ+FK7tz2hvJsX/d5ayNb7mtoK/mUm16FCHwlHH8Nkci9TNs7Z+FQngH84/QsybZWCja5ewkB/KCWtByBTVSY3+VCPdtCb+6a1WxhLtAH9xsXYpqi1dj24Q4RQI6yXv4HkSpx/jCxJTcNCoEy4psXulJKD3ySK4sqHGDrDv8T34QvR+SLFWVV5rowJrp820nVnC+Z/cFs/dMkg92vMbyTYT8EwxjOMpm6lcHCLG54QOj5ICOrnEV4HRj46ZgiUADRA+GP3FHPVYZ2RsYuaY4AWV1+Ye2QQf4i6IezTfESD7LxnSIyRuZ+sSrirtfJ5LMt4XBFjD3HOqYB/Tpc+1MTXIPSQ7eSQ71WXi7bOBWEWPX47fuyGA3VCy6y89AGHcI5uArGvpoknUa78oXAtbZx5vu1UF2kB9VmxLlPDcbUJr+JCZmFksPXVgRjF+BtqQKXf8csC5n58gB+LzfChPpFNVwZNGInX6df5hYM5W5TyCb91PV8LTLeX4wq8jM5QXJInQyQZBARmnj0laa9jv47U0GfyagoUGzWuAa3AWGL6v+IDeUE6OxAy+Odw4nDNLK7QCBsvMh1/sHN76VvAT0WLvCX+SRNG/QQ+CFiLZJtgf1LjTmsxbxzqhxiei7CBLv7mZNiwts28233d5Ux9lJGlZw1F7vmoPGzUo8MN8Ih9wKAWn9mdhfNrB2CK3lWHcNZUtp5WfP8D4hBATMztkY/XWZqiz3p+XhURR0UCGWkotdJP+bptWAZMaCsUcx1Y7VT+YHTM/xCESqKJH7iAajKHN28FYsC+9cRbLT6iTR1wyPlZ7aOvtiX+bXNAri5a/AYr+uxJVsapKBRLvgrlq6+gpAAXLI2nx+wOsxvv4NJzMFTc/TdkvvmDOBBPAcQ1rjdHCHETMC9CnsH7UdUxnkIGAN5bKA25GPDnF2ClAoCr19bArRAgFyyNp8709zzKAA2bmbE3QfoUSzXkVsVZg1azNJP5NIdjdWGyK8E3x6YdNGkUrhCYY4VuNxFKzNRYAIS7d84yMuPSaIL0AXJyuBeK+WEoWDsX43zJkZ295Xg1BCsDrFB5AJZv6UwWo/7WapNcbgh4rVLoJWyVmFfQ4z4cajQwjdEhuWgLY/mhZEUQNuFwXsrQ5alKP5omRq6ZCsWTfPWa6WWxru1JMGSOqtUe/ChDz22Gc8sM/pe27i/PMiQ8z4xXGNXs0B9KQJgd79M1DgaPr66f0Ccro9fpWKsfjmc9421RuBFA2GJZfKplzwN2NlKq2WQfmf1iafM4PCfwR1CcpRIqwoklMA8spYW4s0sAXgwN/RQ9vAowDHAiuPWrB/X4oqnaPH2zCwB2AgWIWQ+04j+ukoOhwav+9fXbIO6+zme6in+QOSKciCmcGhOfh5Yo0KpAIBcsjafJBgAk1ithc3SQpgeparNOnXqvvWcR06wN2G+7mrECIbF6iwalim4P0lHPY8ysxo2fHV/BRdcLjAE50WucVULOKMtpGxikYOjOp1usg6ZrtT/Y5jDuJJOp7hrecDjbYUzLxTj6aHpm+AFS3xdyDG7kFblj0gEAEbztzNkbyvG2CScuNIyI2tU7J3uofNRLv/QigxPub6CmrObbeSVC2XX4f8JP1rzPYQ3PLNGQ4CEZrZ66q62oRAKOO06wdS2Wnq3x6vMfmuj3tsEXrdcTuKiJ3Ceekz7SkTof7gxS5Y9xD9TFDbPRVXuZN1WJ+JHu68f4LhcD1AEuw3RYsWS5zPqFJu0Q1UYzM7o36GGikaE0Hw3HekCnft4AtI2WsNs7xD"
      }
    },
    "```python\n        def row2image(row):\n            pixels, emotion = row['pixels'], emotion_map[row['emotion']]\n            img = np.array(pixels.split(), dtype=np.uint8)\n            img = img.reshape((48, 48))\n            image = np.zeros((48, 48, 3), dtype=np.uint8)\n            image[:, :, 0] = img\n            image[:, :, 1] = img\n            image[:, :, 2] = img\n            return image, emotion\n\n        plt.figure(0, figsize=(16,10))\n        # Get the actual emotion codes present after removal and sort them\n        present_emotion_codes = sorted(data['emotion'].unique())\n        \n        for idx, emotion_code in enumerate(present_emotion_codes):\n            # Ensure there's at least one image for the emotion before trying to access iloc[0]\n            if not data[data['emotion'] == emotion_code].empty:\n                face = data[data['emotion'] == emotion_code].iloc[0]\n                img, label = row2image(face)\n                plt.subplot(2,4,idx+1) # Use idx for subplot positioning\n                plt.imshow(img) # Corrected: img instead of img[0]\n                plt.title(label)\n            else:\n                print(f\"No images found for emotion code {emotion_code} after filtering.\")\n\n        plt.show()\n        ```",
    "\n\n*   **Bug: `num_classes` Inconsistency (Root Cause: Data Confusion / Implementation Error)**\n    *   **Issue:** The parameter `num_classes` is initialized to `7` (`cell_index: 18`), but the 'disgust' class (emotion `1`) was removed. This means there are effectively only 6 classes. This inconsistency will affect `to_categorical` (which will create 7-element vectors with one always zero) and the final `Dense` layer of the model (which will have 7 output neurons for a 6-class problem).\n    *   **Impact:** While `to_categorical` might not immediately error, it's logically incorrect. The model's output layer will have an extra, unused neuron, potentially affecting training efficiency or interpretation.\n    *   **Correction/Improvement:** Update `num_classes` to reflect the actual number of classes after removal.\n\n    **Corrected Code for `cell_index: 18`:**\n    ",
    "```python\n    #initilize parameters\n    num_classes = 6 # Changed from 7 to 6 to reflect the removal of 'disgust'\n    width, height = 48, 48\n    num_epochs = 50\n    batch_size = 64\n    num_features = 64\n    ```",
    "\n\n*   **Minor Bug: Redundant `pandas` Import (Root Cause: Implementation Error)**\n    *   **Issue:** `import pandas as pd` is present in `cell_index: 9` even though it was already imported in `cell_index: 2`.\n    *   **Impact:** Harmless but unnecessary.\n    *   **Correction/Improvement:** Remove the redundant import from `cell_index: 9`.\n\n*   **Minor Bug: Pointless `disgust_images` Column (Root Cause: Implementation Error)**\n    *   **Issue:** In `cell_index: 9`, a `disgust_images` column is created and populated, but then all rows containing that data are immediately dropped.\n    *   **Impact:** Wastes memory and computation for a column that is never used.\n    *   **Correction/Improvement:** Remove the lines related to `disgust_images` column creation if the intent is to simply drop the 'disgust' rows.\n\n    **Corrected Code for `cell_index: 9` (assuming 'disgust' removal is intended):**\n    ",
    "```python\n    # Remove rows with emotion == 1 (Disgust)\n    data.drop(data[data['emotion'] == 1].index, inplace=True)\n\n    # afficher la nouvelle forme du DataFrame\n    print(data.shape)\n    ```",
    "\n\n*   **Potential Bug: `KeyError` in Plotting Training History (Root Cause: Library Cause / Implementation Error)**\n    *   **Issue:** The plotting code (`cell_index: 24`) uses `history.history['acc']` and `history.history['val_acc']`. In newer versions of Keras/TensorFlow, the keys for accuracy are typically `'accuracy'` and `'val_accuracy'`.\n    *   **Impact:** Would cause a `KeyError` if the Keras version uses the updated keys.\n    *   **Correction/Improvement:** Update the keys to `'accuracy'` and `'val_accuracy'`.\n\n    **Corrected Code for `cell_index: 24`:**\n    ",
    "```python\n    fig, axes = plt.subplots(1,2, figsize=(18, 6))\n    # Plot training & validation accuracy values\n    axes[0].plot(history.history['accuracy']) # Changed 'acc' to 'accuracy'\n    axes[0].plot(history.history['val_accuracy']) # Changed 'val_acc' to 'val_accuracy'\n    axes[0].set_title('Model accuracy')\n    axes[0].set_ylabel('Accuracy')\n    axes[0].set_xlabel('Epoch')\n    axes[0].legend(['Train', 'Validation'], loc='upper left')\n\n    # Plot training & validation loss values\n    axes[1].plot(history.history['loss'])\n    axes[1].plot(history.history['val_loss'])\n    axes[1].set_title('Model loss')\n    axes[1].set_ylabel('Loss')\n    axes[1].set_xlabel('Epoch')\n    axes[1].legend(['Train', 'Validation'], loc='upper left')\n    plt.show()\n    ```",
    "\n\n**2. Security Analysis**\n\n*   **Bandit Report:** The provided Bandit security report indicates **no security issues** were found in the notebook's Python code.\n*   **Conclusion:** Based on the static analysis performed by Bandit, the code does not contain common security vulnerabilities like insecure function calls, hardcoded credentials, or other patterns that could lead to exploits. This is a positive finding.\n\n**3. Confidentiality Analysis**\n\n*   **Information Available:** There is no information in the notebook or supporting reports that suggests any confidentiality issues. The dataset `fer2013.csv` is from a Kaggle open resource and is for facial expression recognition, which typically does not involve personally identifiable information (PII) in a way that would raise confidentiality concerns in this context.\n*   **Conclusion:** No confidentiality issues are identified based on the available information.\n\n**4. Resource Handling Analysis**\n\n*   **Issue:** The notebook involves training a Convolutional Neural Network (CNN), which can be resource-intensive (CPU/GPU, memory). While the code itself doesn't show explicit resource leaks, inefficient handling could lead to high resource consumption.\n*   **Current State:** The use of `EarlyStopping` (`cell_index: 22`) is a good practice for resource management during training, as it prevents unnecessary training epochs once performance plateaus. The `ImageDataGenerator` is also efficient for handling large datasets by loading images in batches.\n*   **Conclusion:** No explicit resource leaks or poor resource handling practices are identified. The use of `EarlyStopping` is a positive aspect of resource management.\n\n**5. Error Management Analysis**\n\n*   **Issue:** The original notebook, as initially presented, would have crashed due to `NameError` (for `data` and subsequent variables) and `IndexError` (in the image display loop). These are unhandled exceptions that halt execution.\n*   **Impact:** Prevents the notebook from running to completion and makes debugging difficult.\n*   **Correction/Improvement:** The corrections proposed above (loading `data`, fixing the `num_classes` inconsistency, and adjusting the image display loop) directly address these errors, allowing the notebook to execute without crashing at these points. Implementing robust error handling (e.g., `try-except` blocks) for data loading or specific operations could further improve resilience, but the primary goal here is to fix the root causes of the crashes.\n\n**6. Dependency or Environment Consistency Analysis**\n\n*   **Issue: Deprecated `model.fit_generator` (Root Cause: Library Cause)**\n    *   **Issue:** The `model.fit_generator` method used for training (`cell_index: 22`) is deprecated in recent versions of Keras/TensorFlow.\n    *   **Impact:** While it might still work, it can lead to deprecation warnings and may be removed in future library versions, causing compatibility issues.\n    *   **Correction/Improvement:** Replace `model.fit_generator` with `model.fit`. The `ImageDataGenerator.flow()` method is designed to work seamlessly with `model.fit`.\n\n    **Corrected Code for `cell_index: 22`:**\n    ",
    "```python\n    # ... (ImageDataGenerator and EarlyStopping definitions) ...\n\n    # Use model.fit instead of model.fit_generator (deprecated)\n    history = model.fit(data_generator.flow(train_X, train_Y, batch_size),\n                            steps_per_epoch=len(train_X) / batch_size,\n                            epochs=num_epochs,\n                            verbose=2,\n                            callbacks = [es],\n                            validation_data=(val_X, val_Y))\n    ```",
    "\n\n### Summary of Corrected/Improved Code (assuming 'disgust' removal is intended):",
    "```python\n# --- cell_index: 4 ---\ndata = pd.read_csv('data/fer2013.csv')\n#check data shape\ndata.shape\n\n# --- cell_index: 9 ---\n# Removed redundant import and pointless disgust_images column creation\n# Remove rows with emotion == 1 (Disgust)\ndata.drop(data[data['emotion'] == 1].index, inplace=True)\n# afficher la nouvelle forme du DataFrame\nprint(data.shape)\n\n# --- cell_index: 10 ---\n#check target labels\n# Updated emotion_map to reflect the removal of emotion 1 (Disgust)\nemotion_map = {0: 'Angry', 2: 'Fear', 3: 'Happy', 4: 'Sad', 5: 'Surprise', 6: 'Neutral'}\nemotion_counts = data['emotion'].value_counts(sort=False).reset_index()\nemotion_counts.columns = ['emotion', 'number']\nemotion_counts['emotion'] = emotion_counts['emotion'].map(emotion_map)\nemotion_counts\n\n# --- cell_index: 13 ---\ndef row2image(row):\n    pixels, emotion = row['pixels'], emotion_map[row['emotion']]\n    img = np.array(pixels.split(), dtype=np.uint8)\n    img = img.reshape((48, 48))\n    image = np.zeros((48, 48, 3), dtype=np.uint8)\n    image[:, :, 0] = img\n    image[:, :, 1] = img\n    image[:, :, 2] = img\n    return image, emotion\n\nplt.figure(0, figsize=(16,10))\npresent_emotion_codes = sorted(data['emotion'].unique()) # Get actual unique emotion codes\nfor idx, emotion_code in enumerate(present_emotion_codes):\n    if not data[data['emotion'] == emotion_code].empty:\n        face = data[data['emotion'] == emotion_code].iloc[0]\n        img, label = row2image(face)\n        plt.subplot(2,4,idx+1)\n        plt.imshow(img) # Corrected: img instead of img[0]\n        plt.title(label)\n    else:\n        print(f\"No images found for emotion code {emotion_code} after filtering.\")\nplt.show()\n\n# --- cell_index: 16 (Barplot Class Distribution) ---\n# Update emotion_labels to match the 6 classes\nemotion_labels = ['Angry', 'Fear', 'Happy', 'Sad', 'Surprise', 'Neutral']\n# ... rest of the setup_axe function and plotting calls ...\n\n# --- cell_index: 18 ---\n#initilize parameters\nnum_classes = 6 # Changed from 7 to 6 to reflect the removal of 'disgust'\nwidth, height = 48, 48\nnum_epochs = 50\nbatch_size = 64\nnum_features = 64\n\n# --- cell_index: 22 ---\n# ... (ImageDataGenerator and EarlyStopping definitions) ...\n# Use model.fit instead of model.fit_generator (deprecated)\nhistory = model.fit(data_generator.flow(train_X, train_Y, batch_size),\n                        steps_per_epoch=len(train_X) / batch_size,\n                        epochs=num_epochs,\n                        verbose=2,\n                        callbacks = [es],\n                        validation_data=(val_X, val_Y))\n\n# --- cell_index: 24 ---\nfig, axes = plt.subplots(1,2, figsize=(18, 6))\n# Plot training & validation accuracy values\naxes[0].plot(history.history['accuracy']) # Changed 'acc' to 'accuracy'\naxes[0].plot(history.history['val_accuracy']) # Changed 'val_acc' to 'val_accuracy'\naxes[0].set_title('Model accuracy')\naxes[0].set_ylabel('Accuracy')\naxes[0].set_xlabel('Epoch')\naxes[0].legend(['Train', 'Validation'], loc='upper left')\n\n# Plot training & validation loss values\naxes[1].plot(history.history['loss'])\naxes[1].plot(history.history['val_loss'])\naxes[1].set_title('Model loss')\naxes[1].set_ylabel('Loss')\naxes[1].set_xlabel('Epoch')\naxes[1].legend(['Train', 'Validation'], loc='upper left')\nplt.show()\n\n# --- cell_index: 28 (plot_confusion_matrix function) ---\ndef plot_confusion_matrix(y_true, y_pred, classes,\n                          normalize=False,\n                          title=None,\n                          cmap=plt.cm.Blues):\n    # ... (function body, remove redundant 'classes = classes' line) ...\n    # The call to this function will use the updated emotion_labels\n```"
  ]
}